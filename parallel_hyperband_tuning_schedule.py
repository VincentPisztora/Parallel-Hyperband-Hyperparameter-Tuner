# -*- coding: utf-8 -*-

###############################################################################

"""
Description: 
    - An implementation of the Hyperband hyperparameter tuning algorithm (described in https://arxiv.org/pdf/1603.06560),
    - Implemented such that each trial can be run in parallel to all other trials as a separate batch job
    - Useful for avoiding memory leaks from one trial round to the next

Inputs:
    - experiment_id: The name given to the set of hyperparameter trials generated by this script
    - out_path: The path to which the tuning_schedule is saved
    - max_epochs: [Hyperband parameter] corresponds to R in the Hyperband paper
    - factor: [Hyperband parameter] corresponds to eta in the Hyperband paper
Outputs:
    - One csv file for each Hyperband bracket, each representing the corresponding bracket's tuning schedule
    The file is named according in the following format: tuning_tracker_{experiment_id}_epochs_{max_epochs}_factor_{factor}_bracket_{bracket}.csv
    Each tuning schedule consists of a table where each row corresponds to a trial (ie a hyperparameter setting)
    The table columns consist of two types, type A which is consistent across experiments, and type B which can differ across experiments
    Type A: 
        - 'trial': This column is a unique id for the trial within its bracket
        - 'bracket': This column contains the bracket associated with each trial
        - 'round_{i}_status': These columns (one per round) contain the current status of each trial (io: awaiting survival decision, i: in (survived), o: out, p: in progress, f: finished)
        - 'round_{i}_result': These columns (one per round) contain the evaluation metric at the end of each round for each completed trial or -1 for trial rounds not completed
    Type B: Columns corresponding to a particular hyperparameter being tuned
    
Notes:
    - This script must be edited to change which hyperparameters are explored and the range of exploration
    - The evaluation metric must be nonnegative and larger is better
"""

###############################################################################

import os
import argparse
import numpy as np
import pandas as pd

###############################################################################

parser = argparse.ArgumentParser()

parser.add_argument('--experiment_id', default='Exp1', type=str, metavar='N',help='The name given to the set of hyperparameter trials generated by this script')
parser.add_argument('--out_path', default='/', type=str, metavar='N',help='The path to which the tuning_schedule is saved')
parser.add_argument('--max_epochs', default=800, type=int, metavar='N',help='[Hyperband parameter] corresponds to R in the Hyperband paper')
parser.add_argument('--factor', default=3, type=int, metavar='N',help='[Hyperband parameter] corresponds to eta in the Hyperband paper')

args = parser.parse_args()
print(f'args: {args}')
experiment_id = args.experiment_id
out_path = args.out_path
eta = args.factor
R = args.max_epochs

###############################################################################

optimizer_type_values = ['Adam','AdamW']
lr_values = [m * 10**-i for i in range(6, 0, -1) for m in (1, 5) if not (i == 1 and m == 5)]
lrsch_values = ['None','cos']
wt_values = [0.,1e-1,5e-2,1e-2,5e-3,1e-3,5e-4,1e-4,5e-5,1e-5,5e-6,1e-6,5e-7,1e-7]
cdp_values = [.1*i for i in range(0,10)]

crop_p_values = [.1*i for i in range(0,11)]
camn_values = [.05*i for i in range(10,20)]
camx_values = [.05*i for i in range(11,21)]

color_p_values = [.1*i for i in range(0,11)]
cjs_values = [.1*i for i in range(1,11)]

maskp_values = [.75]
drop_values = [0.1]
ssl_values = ['vitmae'] #'simclr'
crop_type_values = ['resize','wrap']
reconstr_values = ['aug'] #'original'

###############################################################################
np.random.seed(0)

s_max = np.floor(np.emath.logn(n=eta,x=R)).astype(int)
B = (s_max + 1)*R

for s in range(s_max+1):
    n = np.ceil((B/R)*(eta**s/(s+1))).astype(int)
    r = R*(eta**-s)
    
    ###########################################################################
    
    optimizer_type = np.random.choice(a=optimizer_type_values,size=n)
    lr = np.random.choice(a=lr_values,size=n)
    lrsch = np.random.choice(a=lrsch_values,size=n)
    wt = np.random.choice(a=wt_values,size=n)

    cdp_he = np.random.choice(a=cdp_values,size=n)
    cdp_mif = np.random.choice(a=cdp_values,size=n)
    cdp_dapi = np.random.choice(a=cdp_values,size=n)

    crop_p = np.random.choice(a=crop_p_values,size=n)
    camn,camx = [],[]
    for crop_p_j in crop_p:
        if crop_p_j > 0.:
            j = np.random.choice(a=camn_values,size=1)[0]
            camn.append(j)
            valid_camx_values = [k for k in camx_values if k>j]
            k = np.random.choice(a=valid_camx_values,size=1)[0]
            camx.append(k)
        else:
            camn.append(0.95)
            camx.append(1.0)
    camn,camx = np.array(camn),np.array(camx)

    color_p = np.random.choice(a=color_p_values,size=n)
    cjs_mif,cjs_he = [],[]
    for color_p_j in color_p:
        if color_p_j > 0.:
            j = np.random.choice(a=cjs_values,size=1)[0]
            cjs_mif.append(j)
            k = np.random.choice(a=cjs_values,size=1)[0]
            cjs_he.append(k)
        else:
            cjs_mif.append(0.0)
            cjs_he.append(0.0)
    cjs_mif,cjs_he = np.array(cjs_mif), np.array(cjs_he)
    
    maskp = np.random.choice(a=maskp_values,size=n)
    drop = np.random.choice(a=drop_values,size=n)
    ssl = np.random.choice(a=ssl_values,size=n)
    crop_type = np.random.choice(a=crop_type_values,size=n)
    reconstr = np.random.choice(a=reconstr_values,size=n)
    
    ###########################################################################
    
    df = pd.DataFrame({'optimizer_type':optimizer_type,'lr':lr,'lrsch':lrsch,
                       'wt':wt,'cdp_he':cdp_he,'cdp_mif':cdp_mif,'cdp_dapi':cdp_dapi,
                       'crop_p':crop_p,'camn':camn,'camx':camx,
                       'color_p':color_p,'cjs_mif':cjs_mif,'cjs_he':cjs_he,
                       'maskp':maskp,'drop':drop,'ssl':ssl,
                       'crop_type':crop_type,'reconstr':reconstr})
    
    for j in range(s+1):
        df[f'round_{j}_status'] = 'io'
        df[f'round_{j}_result'] = -1.
    
    df['trial'] = [i for i in range(df.shape[0])]
    df['bracket'] = s
    
    df.to_csv(os.path.join(out_path,f'tuning_tracker_{experiment_id}_epochs_{R}_factor_{eta}_bracket_{s}.csv'),index=False)

###############################################################################


